<!-- manual page source format generated by PolyglotMan v3.0.9, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>gcov(1)</TITLE>
</HEAD>
<BODY bgcolor=white>
<A HREF="#toc">Table of Contents</A><P>

<H2><A NAME="sect0" HREF="#toc0">Name</A></H2>

<P>
gcov - coverage testing tool
<P>

<H2><A NAME="sect1" HREF="#toc1"><B>Synopsis</B></A></H2>

<P>
gcov [<B>-v</B>|<B>--version</B>] [<B>-h</B>|<B>--help</B>]<BR>

[<B>-a</B>|<B>--all-blocks</B>]<BR>

[<B>-b</B>|<B>--branch-probabilities</B>]<BR>

[<B>-c</B>|<B>--branch-counts</B>]<BR>

[<B>-n</B>|<B>--no-output</B>]<BR>

[<B>-l</B>|<B>--long-file-names</B>]<BR>

[<B>-p</B>|<B>--preserve-paths</B>]<BR>

[<B>-f</B>|<B>--function-summaries</B>]<BR>

[<B>-o</B>|<B>--object-directory</B> <I>directory|file</I>] <I>sourcefile</I>
[<B>-u</B>|<B>--unconditional-branches</B>]
<P>

<H2><A NAME="sect2" HREF="#toc2"><B>Description</B></A></H2>

<P>
<B>gcov</B> is a test coverage program. Use it in concert with GCC to analyze
your programs to help create more efficient, faster running code and to
discover untested parts of your program. You can use <B>gcov</B> as a profiling
tool to help discover where your optimization efforts will best
affect your code. You can also use <B>gcov</B> along with the other profiling
tool, <B>gprof</B>, to assess which parts of your code use the greatest amount
of computing time.
<P>
<P>
Profiling tools help you analyze your code's performance. Using a profiler
such as <B>gcov</B> or <B>gprof</B>, you can find out some basic performance
statistics, such as:
<P>

<DL>

<DT>&#183; how often each line of code executes</DT></DT>
<DD>
<P>
</DD>

<DT>&#183; what lines of code are actually executed</DT></DT>
<DD>
<P>
</DD>

<DT>&#183; how much computing time each section of code uses</DT></DT>
<DD>
<P>
</DD>
</DL>
<P>
Once you know these things about how your code works when compiled, you
can look at each module to see which modules should be optimized. <B>gcov</B>
helps you determine where to work on optimization.
<P>
<P>
Software developers also use coverage testing in concert with testsuites,
to make sure software is actually good enough for a release.
Testsuites can verify that a program works as expected; a coverage program
tests to see how much of the program is exercised by the testsuite.
Developers can then determine what kinds of test cases need to
be added to the testsuites to create both better testing and a better
final product.
<P>
<P>
You should compile your code without optimization if you plan to use
<B>gcov</B> because the optimization, by combining some lines of code into one
function, may not give you as much information as you need to look for
`hot spots' where the code is using a great deal of computer time.
Likewise, because <B>gcov</B> accumulates statistics by line (at the lowest
resolution), it works best with a programming style that places only
one statement on each line. If you use complicated macros that expand
to loops or to other control structures, the statistics are less helpful---they
only report on the line where the macro call appears. If
your complex macros behave like functions, you can replace them with
inline functions to solve this problem.
<P>
<P>
<B>gcov</B> creates a logfile called <I>sourcefile.gcov</I> which indicates how many
times each line of a source file <I>sourcefile.c</I> has executed. You can
use these logfiles along with <B>gprof</B> to aid in fine-tuning the performance
of your programs. <B>gprof</B> gives timing information you can use
along with the information you get from <B>gcov</B>.
<P>
<P>
<B>gcov</B> works only on code compiled with GCC. It is not compatible with
any other profiling or test coverage mechanism.
<P>

<H2><A NAME="sect3" HREF="#toc3"><B>Options</B></A></H2>

<P>
<B>-h</B><BR>

<B>--help</B><BR>

Display help about using <B>gcov</B> (on the standard output), and exit
without doing any further processing.
<P>

<DL>

<DT><B>-v</B></DT></DT>
<DD>
<B>--version</B>
Display the <B>gcov</B> version number (on the standard output), and exit
without doing any further processing.
<P>
</DD>

<DT><B>-a</B></DT></DT>
<DD>
<B>--all-blocks</B>
Write individual execution counts for every basic block. Normally
gcov outputs execution counts only for the main blocks of a line.
With this option you can determine if blocks within a single line
are not being executed.
<P>
</DD>

<DT><B>-b</B></DT></DT>
<DD>
<B>--branch-probabilities</B>
Write branch frequencies to the output file, and write branch summary
info to the standard output. This option allows you to see
how often each branch in your program was taken. Unconditional
branches will not be shown, unless the <B>-u</B> option is given.
<P>
</DD>

<DT><B>-c</B></DT></DT>
<DD>
<B>--branch-counts</B>
Write branch frequencies as the number of branches taken, rather
than the percentage of branches taken.
<P>
</DD>

<DT><B>-n</B></DT></DT>
<DD>
<B>--no-output</B>
Do not create the <B>gcov</B> output file.
<P>
</DD>

<DT><B>-l</B></DT></DT>
<DD>
<B>--long-file-names</B>
Create long file names for included source files. For example, if
the header file <I>x.h</I> contains code, and was included in the file
<I>a.c</I>, then running <B>gcov</B> on the file <I>a.c</I> will produce an output file
called <I>a.c##x.h.gcov</I> instead of <I>x.h.gcov</I>. This can be useful if
<I>x.h</I> is included in multiple source files. If you use the <B>-p</B>
option, both the including and included file names will be complete
path names.
<P>
</DD>

<DT><B>-p</B></DT></DT>
<DD>
<B>--preserve-paths</B>
Preserve complete path information in the names of generated <I>.gcov</I>
files. Without this option, just the filename component is used.
With this option, all directories are used, with <B>/</B> characters
translated to <B>#</B> characters, <I>.</I> directory components removed and <I>..</I>
components renamed to <B>^</B>. This is useful if sourcefiles are in several
different directories. It also affects the <B>-l</B> option.
<P>
</DD>

<DT><B>-f</B></DT></DT>
<DD>
<B>--function-summaries</B>
Output summaries for each function in addition to the file level
summary.
<P>
</DD>

<DT><B>-o</B> <I>directory|file</I></DT></DT>
<DD>
<B>--object-directory</B> <I>directory</I>
<B>--object-file</B> <I>file</I>
Specify either the directory containing the gcov data files, or the
object path name. The <I>.gcno</I>, and <I>.gcda</I> data files are searched for
using this option. If a directory is specified, the data files are
in that directory and named after the source file name, without its
extension. If a file is specified here, the data files are named
after that file, without its extension. If this option is not supplied,
it defaults to the current directory.
<P>
</DD>

<DT><B>-u</B></DT></DT>
<DD>
<B>--unconditional-branches</B>
When branch probabilities are given, include those of unconditional
branches. Unconditional branches are normally not interesting.
<P>
</DD>
</DL>
<P>
<B>gcov</B> should be run with the current directory the same as that when you
invoked the compiler. Otherwise it will not be able to locate the
source files. <B>gcov</B> produces files called <I>mangledname.gcov</I> in the current
directory. These contain the coverage information of the source
file they correspond to. One <I>.gcov</I> file is produced for each source
file containing code, which was compiled to produce the data files.
The <I>mangledname</I> part of the output file name is usually simply the
source file name, but can be something more complicated if the <B>-l</B> or <B>-p</B>
options are given. Refer to those options for details.
<P>
<P>
The <I>.gcov</I> files contain the <B>:</B> separated fields along with program
source code. The format is
<P>
<P>
&lt;execution_count&gt;:&lt;line_number&gt;:&lt;source line text&gt;
<P>
<P>
Additional block information may succeed each line, when requested by
command line option. The <I>execution</I><B>_</B><I>count</I> is <B>-</B> for lines containing no
code and <B>#####</B> for lines which were never executed. Some lines of
information at the start have <I>line</I><B>_</B><I>number</I> of zero.
<P>
<P>
The preamble lines are of the form
<P>

<DL>

<DT>-:0:&lt;tag&gt;:&lt;value&gt;</DT></DT>
<DD>
<P>
</DD>
</DL>
<P>
The ordering and number of these preamble lines will be augmented as
<B>gcov</B> development progresses --- do not rely on them remaining
unchanged. Use <I>tag</I> to locate a particular preamble line.
<P>
<P>
The additional block information is of the form
<P>
<P>
&lt;tag&gt; &lt;information&gt;
<P>
<P>
The <I>information</I> is human readable, but designed to be simple enough for
machine parsing too.
<P>
<P>
When printing percentages, 0% and 100% are only printed when the values
are <I>exactly</I> 0% and 100% respectively. Other values which would conventionally
be rounded to 0% or 100% are instead printed as the nearest
non-boundary value.
<P>
<P>
When using <B>gcov</B>, you must first compile your program with two special
GCC options: <B>-fprofile-arcs</B> <B>-ftest-coverage</B>. This tells the compiler
to generate additional information needed by gcov (basically a flow
graph of the program) and also includes additional code in the object
files for generating the extra profiling information needed by gcov.
These additional files are placed in the directory where the object
file is located.
<P>
<P>
Running the program will cause profile output to be generated. For
each source file compiled with <B>-fprofile-arcs</B>, an accompanying <I>.gcda</I>
file will be placed in the object file directory.
<P>
<P>
Running <B>gcov</B> with your program's source file names as arguments will
now produce a listing of the code along with frequency of execution for
each line. For example, if your program is called <I>tmp.c</I>, this is what
you see when you use the basic <B>gcov</B> facility:
<P>
<P>
$ gcc -fprofile-arcs -ftest-coverage tmp.c
$ a.out<BR>

$ gcov tmp.c<BR>

90.00% of 10 source lines executed in file tmp.c
Creating tmp.c.gcov.
<P>
<P>
The file <I>tmp.c.gcov</I> contains output from <B>gcov</B>. Here is a sample:
<P>

<DL>

<DT>-: </DT></DT>
<DD>   0:Source:tmp.c
</DD>

<DT>-: </DT></DT>
<DD>   0:Graph:tmp.gcno
</DD>

<DT>-: </DT></DT>
<DD>   0:Data:tmp.gcda
</DD>

<DT>-: </DT></DT>
<DD>   0:Runs:1
</DD>

<DT>-: </DT></DT>
<DD>   0:Programs:1
</DD>

<DT>-: </DT></DT>
<DD>   1:#include &lt;stdio.h&gt;
</DD>

<DT>-: </DT></DT>
<DD>   2:
</DD>

<DT>-: </DT></DT>
<DD>   3:int main (void)
</DD>

<DT>1: </DT></DT>
<DD>   4:{
</DD>

<DT>1: </DT></DT>
<DD>   5: int i, total;
</DD>

<DT>-: </DT></DT>
<DD>   6:
</DD>

<DT>1: </DT></DT>
<DD>   7: total = 0;
</DD>

<DT>-: </DT></DT>
<DD>   8:
</DD>

<DT>11: </DT></DT>
<DD>   9: for (i = 0; i &lt; 10; i++)
10: 10:    total += i;
-: 11:
1: 12: if (total != 45)
#####: 13:    printf ("Failure\n");
-: 14: else
1: 15:    printf ("Success\n");
1: 16: return 0;
-: 17:}
<P>
</DD>
</DL>
<P>
When you use the <B>-a</B> option, you will get individual block counts, and
the output looks like this:
<P>

<DL>

<DT>-: </DT></DT>
<DD>   0:Source:tmp.c
</DD>

<DT>-: </DT></DT>
<DD>   0:Graph:tmp.gcno
</DD>

<DT>-: </DT></DT>
<DD>   0:Data:tmp.gcda
</DD>

<DT>-: </DT></DT>
<DD>   0:Runs:1
</DD>

<DT>-: </DT></DT>
<DD>   0:Programs:1
</DD>

<DT>-: </DT></DT>
<DD>   1:#include &lt;stdio.h&gt;
</DD>

<DT>-: </DT></DT>
<DD>   2:
</DD>

<DT>-: </DT></DT>
<DD>   3:int main (void)
</DD>

<DT>1: </DT></DT>
<DD>   4:{
</DD>

<DT>1: </DT></DT>
<DD>   4-block 0
</DD>

<DT>1: </DT></DT>
<DD>   5: int i, total;
</DD>

<DT>-: </DT></DT>
<DD>   6:
</DD>

<DT>1: </DT></DT>
<DD>   7: total = 0;
</DD>

<DT>-: </DT></DT>
<DD>   8:
</DD>

<DT>11: </DT></DT>
<DD>   9: for (i = 0; i &lt; 10; i++)
</DD>

<DT>11: </DT></DT>
<DD>   9-block 0
10: 10:    total += i;
10: 10-block 0
-: 11:
1: 12: if (total != 45)
1: 12-block 0
#####: 13:    printf ("Failure\n");
$$$$$: 13-block 0
-: 14: else
1: 15:    printf ("Success\n");
1: 15-block 0
1: 16: return 0;
1: 16-block 0
-: 17:}
<P>
</DD>
</DL>
<P>
In this mode, each basic block is only shown on one line -- the last
line of the block. A multi-line block will only contribute to the execution
count of that last line, and other lines will not be shown to
contain code, unless previous blocks end on those lines. The total
execution count of a line is shown and subsequent lines show the execution
counts for individual blocks that end on that line. After each
block, the branch and call counts of the block will be shown, if the <B>-b</B>
option is given.
<P>
<P>
Because of the way GCC instruments calls, a call count can be shown
after a line with no individual blocks. As you can see, line 13 contains
a basic block that was not executed.
<P>
<P>
When you use the <B>-b</B> option, your output looks like this:
<P>
<P>
$ gcov -b tmp.c<BR>

90.00% of 10 source lines executed in file tmp.c
80.00% of 5 branches executed in file tmp.c
80.00% of 5 branches taken at least once in file tmp.c
50.00% of 2 calls executed in file tmp.c
Creating tmp.c.gcov.
<P>
<P>
Here is a sample of a resulting <I>tmp.c.gcov</I> file:
<P>

<DL>

<DT>-: </DT></DT>
<DD>   0:Source:tmp.c
</DD>

<DT>-: </DT></DT>
<DD>   0:Graph:tmp.gcno
</DD>

<DT>-: </DT></DT>
<DD>   0:Data:tmp.gcda
</DD>

<DT>-: </DT></DT>
<DD>   0:Runs:1
</DD>

<DT>-: </DT></DT>
<DD>   0:Programs:1
</DD>

<DT>-: </DT></DT>
<DD>   1:#include &lt;stdio.h&gt;
</DD>

<DT>-: </DT></DT>
<DD>   2:
</DD>

<DT>-: </DT></DT>
<DD>   3:int main (void)
function main called 1 returned 1 blocks executed 75%
</DD>

<DT>1: </DT></DT>
<DD>   4:{
</DD>

<DT>1: </DT></DT>
<DD>   5: int i, total;
</DD>

<DT>-: </DT></DT>
<DD>   6:
</DD>

<DT>1: </DT></DT>
<DD>   7: total = 0;
</DD>

<DT>-: </DT></DT>
<DD>   8:
</DD>

<DT>11: </DT></DT>
<DD>   9: for (i = 0; i &lt; 10; i++)
branch 0 taken 91% (fallthrough)
branch 1 taken 9%
10: 10:    total += i;
-: 11:
1: 12: if (total != 45)
branch 0 taken 0% (fallthrough)
branch 1 taken 100%
#####: 13:    printf ("Failure\n");
</DD>

<DT>call </DT></DT>
<DD>   0 never executed
-: 14: else
1: 15:    printf ("Success\n");
</DD>

<DT>call </DT></DT>
<DD>   0 called 1 returned 100%
1: 16: return 0;
-: 17:}
<P>
</DD>
</DL>
<P>
For each function, a line is printed showing how many times the function
is called, how many times it returns and what percentage of the
function's blocks were executed.
<P>
<P>
For each basic block, a line is printed after the last line of the
basic block describing the branch or call that ends the basic block.
There can be multiple branches and calls listed for a single source
line if there are multiple basic blocks that end on that line. In this
case, the branches and calls are each given a number. There is no simple
way to map these branches and calls back to source constructs. In
general, though, the lowest numbered branch or call will correspond to
the leftmost construct on the source line.
<P>
<P>
For a branch, if it was executed at least once, then a percentage indicating
the number of times the branch was taken divided by the number
of times the branch was executed will be printed. Otherwise, the message
``never executed'' is printed.
<P>
<P>
For a call, if it was executed at least once, then a percentage indicating
the number of times the call returned divided by the number of
times the call was executed will be printed. This will usually be
100%, but may be less for functions call exit or longjmp", and thus
may not return every time they are called.
<P>
<P>
The execution counts are cumulative. If the example program were executed
again without removing the <I>.gcda</I> file, the count for the number
of times each line in the source was executed would be added to the
results of the previous run(s). This is potentially useful in several
ways. For example, it could be used to accumulate data over a number
of program runs as part of a test verification suite, or to provide
more accurate long-term information over a large number of program
runs.
<P>
<P>
The data in the <I>.gcda</I> files is saved immediately before the program
exits. For each source file compiled with <B>-fprofile-arcs</B>, the profiling
code first attempts to read in an existing <I>.gcda</I> file; if the file
doesn't match the executable (differing number of basic block counts)
it will ignore the contents of the file. It then adds in the new execution
counts and finally writes the data to the file.
<P>
<P>
<B>Using</B> <B>gcov</B> <B>with</B> <B>GCC</B> <B>Optimization</B>
<P>
<P>
If you plan to use <B>gcov</B> to help optimize your code, you must first compile
your program with two special GCC options: <B>-fprofile-arcs</B>
<B>-ftest-coverage</B>. Aside from that, you can use any other GCC options;
but if you want to prove that every single line in your program was
executed, you should not compile with optimization at the same time.
On some machines the optimizer can eliminate some simple code lines by
combining them with other lines. For example, code like this:
<P>
<P>
if (a != b)<BR>

c = 1;<BR>

else<BR>

c = 0;
<P>
<P>
can be compiled into one instruction on some machines. In this case,
there is no way for <B>gcov</B> to calculate separate execution counts for
each line because there isn't separate code for each line. Hence the
<B>gcov</B> output looks like this if you compiled the program with optimization:
<P>

<DL>

<DT>100: </DT></DT>
<DD>12:if (a != b)
100: 13: c = 1;
100: 14:else
100: 15: c = 0;
<P>
</DD>
</DL>
<P>
The output shows that this block of code, combined by optimization,
executed 100 times. In one sense this result is correct, because there
was only one instruction representing all four of these lines. However,
the output does not indicate how many times the result was 0 and
how many times the result was 1.
<P>
<P>
Inlineable functions can create unexpected line counts. Line counts
are shown for the source code of the inlineable function, but what is
shown depends on where the function is inlined, or if it is not inlined
at all.
<P>
<P>
If the function is not inlined, the compiler must emit an out of line
copy of the function, in any object file that needs it. If <I>fileA.o</I> and
<I>fileB.o</I> both contain out of line bodies of a particular inlineable
function, they will also both contain coverage counts for that function.
When <I>fileA.o</I> and <I>fileB.o</I> are linked together, the linker will,
on many systems, select one of those out of line bodies for all calls
to that function, and remove or ignore the other. Unfortunately, it
will not remove the coverage counters for the unused function body.
Hence when instrumented, all but one use of that function will show
zero counts.
<P>
<P>
If the function is inlined in several places, the block structure in
each location might not be the same. For instance, a condition might
now be calculable at compile time in some instances. Because the coverage
of all the uses of the inline function will be shown for the same
source lines, the line counts themselves might seem inconsistent.
<P>

<H2><A NAME="sect4" HREF="#toc4"><B>See</B> <B>Also</B></A></H2>

<P>
<A HREF="man://gpl/7">gpl(7)</A>
, <A HREF="man://gfdl/7">gfdl(7)</A>
, <A HREF="man://fsf-funding/7">fsf-funding(7)</A>
, <A HREF="man://gcc/1">gcc(1)</A>
 and the Info entry for <I>gcc</I>.
<P>

<H2><A NAME="sect5" HREF="#toc5"><B>Copyright</B></A></H2>

<P>
Copyright (c) 1996, 1997, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free
Software Foundation, Inc.
<P>
<P>
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'' and ``Funding
Free Software'', the Front-Cover texts being (a) (see below), and with
the Back-Cover Texts being (b) (see below). A copy of the license is
included in the <A HREF="man://gfdl/7">gfdl(7)</A>
 man page.
<P>
<P>
(a) The FSF's Front-Cover Text is:
<P>
<P>
A GNU Manual
<P>
<P>
(b) The FSF's Back-Cover Text is:
<P>
<P>
You have freedom to copy and modify this GNU Manual, like GNU
software. Copies published by the Free Software Foundation raise
funds for GNU development.
<P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Synopsis</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Description</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Options</A></LI>
<LI><A NAME="toc4" HREF="#sect4">See Also</A></LI>
<LI><A NAME="toc5" HREF="#sect5">Copyright</A></LI>
</UL>
</BODY></HTML>
